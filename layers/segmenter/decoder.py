from tensorflow.keras.layers import Layer
from tensorflow.keras.saving import register_keras_serializable

from layers.segmenter.conv_blocks import DecoderBlock
from utils.model_utils import L2Regularizer
from typing import Union
from tensorflow.keras.layers import Conv2D


@register_keras_serializable(package='Unet', name='Decoder')
class Decoder(Layer):
    def __init__(self,
                 num_classes: int,
                 dropout_rate: float = 0.0,
                 l2_reg_factor: Union[float] = None,
                 name: str = 'Decoder',
                 **kwargs):
        """
        Implements the decoder layer for the UNet model, by chaining four decoder blocks.

        :param num_classes: (int): number of classes in the label map (mask)
        :param dropout_rate: dropout probability
        :param l2_reg_factor: float, The L2 regularization factor for the regularizer
            function that is applied to the `kernel` weights matrix
        :return: (tensor): The pixel wise label map of the segmented image
        :
        """
        super().__init__(name=name, **kwargs)
        self.num_classes = num_classes
        self.dropout_rate = dropout_rate
        self.l2_reg_factor = l2_reg_factor
        self.regularizer = L2Regularizer()

        self.decoder_block_1 = DecoderBlock(num_filters=512, kernel_size=(3 ,3), strides=(2 ,2),
                                            dropout_rate=dropout_rate, l2_reg_factor=l2_reg_factor,
                                            name='decod_blk_1')

        self.decoder_block_2 = DecoderBlock(num_filters=256, kernel_size=(3 ,3), strides=(2 ,2),
                                            dropout_rate=dropout_rate, l2_reg_factor=l2_reg_factor,
                                            name='decod_blk_2')

        self.decoder_block_3 = DecoderBlock(num_filters=128, kernel_size=(3 ,3), strides=(2 ,2),
                                            dropout_rate=dropout_rate, l2_reg_factor=l2_reg_factor,
                                            name='decod_blk_3')

        self.decoder_block_4 = DecoderBlock(num_filters=64, kernel_size=(3 ,3), strides=(2 ,2),
                                            dropout_rate=dropout_rate, l2_reg_factor=l2_reg_factor,
                                            name='decod_blk_4')

        self.conv2d = Conv2D(filters=num_classes, kernel_size=(1, 1), activation='softmax',
                             kernel_regularizer=self.regularizer(l2_reg_factor), name='predicted_mask')

    def __repr__(self):
        return f"{self.name}"

    def call(self, inputs, *args, **kwargs):
        # f1, f2, f3, f4 are the outputs from the four EncoderBlocks within the UNET Encoder.
        # Each output is generated by Conv2dBlock within each EncoderBlock.
        bottleneck_output, (f1, f2, f3, f4) = inputs
        c6 = self.decoder_block_1([bottleneck_output, f4])
        c7 = self.decoder_block_2([c6, f3])
        c8 = self.decoder_block_3([c7, f2])
        c9 = self.decoder_block_4([c8, f1])
        output = self.conv2d(c9)
        return output

    @property
    def trainable_layers(self):
        return (self.decoder_block_1, self.decoder_block_2, self.decoder_block_3,
                self.decoder_block_4, self.conv2d)

    def get_config(self):
        config = super().get_config()
        config.update({'num_classes': self.num_classes,
                       'dropout_rate': self.dropout_rate,
                       'l2_reg_factor': self.l2_reg_factor,
                       'name': self.name})
        return config


